"use strict";(self.webpackChunkio_github_lyrihkaesa=self.webpackChunkio_github_lyrihkaesa||[]).push([["7193"],{34805:function(e,n,a){a.r(n),a.d(n,{default:()=>h,frontMatter:()=>s,metadata:()=>i,assets:()=>o,toc:()=>d,contentTitle:()=>l});var i=JSON.parse('{"id":"dependency-injection-in-laravel-flament","title":"Dependency Injection in Laravel Filament","description":"Source//medium.com/@cameron_germein/things-i-wish-someone-had-explained-to-me-dependency-injection-in-laravel-filament-what-does-5dae3bbf8f23]","source":"@site/articles/laravel/09-dependency-injection-in-laravel-flament.md","sourceDirName":".","slug":"/dependency-injection-in-laravel-flament","permalink":"/laravel/dependency-injection-in-laravel-flament","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Laravel Eloquent","permalink":"/laravel/eloquent"},"next":{"title":"Alpine JS","permalink":"/laravel/alpine-js"}}'),t=a("85893"),r=a("50065");let s={},l="Dependency Injection in Laravel Filament",o={},d=[{value:"Kesalahan pertama: Berpikir bahwa Service Container SELALU digunakan untuk menyuntikkan dependensi",id:"kesalahan-pertama-berpikir-bahwa-service-container-selalu-digunakan-untuk-menyuntikkan-dependensi",level:2},{value:"Kesalahan kedua: Berpikir bahwa Service Container dapat resolve Model instances",id:"kesalahan-kedua-berpikir-bahwa-service-container-dapat-resolve-model-instances",level:2},{value:"Using the App Facade",id:"using-the-app-facade",level:3},{value:"Using Constructor Injection",id:"using-constructor-injection",level:3},{value:"Any form of Service Container Bindings",id:"any-form-of-service-container-bindings",level:3},{value:"Creating and evaluating my own Closures",id:"creating-and-evaluating-my-own-closures",level:3},{value:"Kesalahan ketiga: Berpikir bahwa <code>Route Model Binding</code> digunakan untuk menyelesaikan Model",id:"kesalahan-ketiga-berpikir-bahwa-route-model-binding-digunakan-untuk-menyelesaikan-model",level:2},{value:"Jadi, bagaimana sebenarnya cara kerjanya? (Ini adalah penjelasan TL;DR)",id:"jadi-bagaimana-sebenarnya-cara-kerjanya-ini-adalah-penjelasan-tldr",level:2},{value:"Tunggu, bagaimana Service Container bekerja?",id:"tunggu-bagaimana-service-container-bekerja",level:2},{value:"Tell me more about Filament\u2019s custom Dependency Injection",id:"tell-me-more-about-filaments-custom-dependency-injection",level:2},{value:"What\u2019s the Long Version?",id:"whats-the-long-version",level:2},{value:"It starts with Livewire",id:"it-starts-with-livewire",level:2},{value:"How is this done in Filament?",id:"how-is-this-done-in-filament",level:2},{value:"Getting the Record into the right places",id:"getting-the-record-into-the-right-places",level:2},{value:"Now to fetch this Record",id:"now-to-fetch-this-record",level:2},{value:"Evaluating the Closure",id:"evaluating-the-closure",level:2},{value:"Implementing the Evaluations",id:"implementing-the-evaluations",level:2},{value:"The final piece of the puzzle",id:"the-final-piece-of-the-puzzle",level:2},{value:"Why are there two different resolveDefault methods?",id:"why-are-there-two-different-resolvedefault-methods",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){let n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"dependency-injection-in-laravel-filament",children:"Dependency Injection in Laravel Filament"})}),"\n",(0,t.jsxs)(n.p,{children:["Source: [",(0,t.jsx)(n.a,{href:"https://medium.com/@cameron_germein/things-i-wish-someone-had-explained-to-me-dependency-injection-in-laravel-filament-what-does-5dae3bbf8f23",children:"https://medium.com/@cameron_germein/things-i-wish-someone-had-explained-to-me-dependency-injection-in-laravel-filament-what-does-5dae3bbf8f23"}),"]"]}),"\n",(0,t.jsx)(n.p,{children:"Hal-hal yang saya harap seseorang dapat menjelaskan kepada saya: Injeksi Ketergantungan pada Filamen Laravel - Apa yang berhasil dan (lebih spesifiknya) tidak berhasil."}),"\n",(0,t.jsxs)(n.p,{children:["Sebagian seseorang yang baru mengenal Laravel dan Filament, satu bidang yang saya geluti adalah ",(0,t.jsx)(n.code,{children:"Dependency Injection"}),". Ketika berhasil, tampaknya ajaib, tetapi ketika tidak berfungsi seperti yang Anda harapkan, sangat membuat frustrasi saat mencoba menentukan alasannya. Ini tidak membantu jika dokumentasi yang Anda baca tentang cara kerja ",(0,t.jsx)(n.code,{children:"DI"})," di proyek Laravel mungkin tidak berlaku untuk proyek Filament."]}),"\n",(0,t.jsx)(n.p,{children:"Sumber frustrasi saya adalah satu tantangan sederhana - mencoba memasukkan/inject contoh Model saat ini. Masalah bagi saya muncul seperti ini: Saya dapat melihat bahwa Filament dengan baik hati mengaktifkan injection of Model instances ke dalam Closures sebagai parameters, yang di ketik seperti:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"Action::make(\"undo\")\r\n  ->button()\r\n  ->requiresConfirmation()\r\n  ->label(\"Undo\")\r\n  ->icon('heroicon-m-x-mark')\r\n  ->color('danger')\r\n  ->action(function (Environment $environment) {\r\n    return $environment->executeUndo();\r\n  });\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Dalam konteks ini, nilai dari $environment adalah contoh saat ini dari Model Lingkungan. Ini berfungsi dengan sempurna. Jadi, Dependency Injection sepenuhnya dipahami! Yang saya butuhkan sekarang adalah untuk menggali lebih dalam sedikit, dan menemukan cara-cara keren lainnya untuk menggunakannya! Maka saya memulai perjalanan saya ke hasil pencarian Google, dan di antara dokumentasi Laravel, menemukan ",(0,t.jsx)(n.a,{href:"https://laravel.com/docs/10.x/container",children:"Service Container"}),". Inilah tempat di mana semuanya mulai terurai."]}),"\n",(0,t.jsx)(n.h2,{id:"kesalahan-pertama-berpikir-bahwa-service-container-selalu-digunakan-untuk-menyuntikkan-dependensi",children:"Kesalahan pertama: Berpikir bahwa Service Container SELALU digunakan untuk menyuntikkan dependensi"}),"\n",(0,t.jsx)(n.p,{children:"Ini telah menjadi sumber utama kebingungan saya. Asumsi saya berjalan seperti ini:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Filament dapat inject instance Model saat ini (ini benar)"}),"\n",(0,t.jsx)(n.li,{children:"Laravel injects dependencies melalui Service Container (ini juga benar)"}),"\n",(0,t.jsx)(n.li,{children:"Oleh karena itu, Filament harus menggunakan Service Container untuk resolve dan inject instance Model saat ini. (Ini benar-benar salah)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Asumsi yang sepenuhnya salah (tetapi pada saat itu tampak masuk akal) ini adalah apa yang telah membuat saya gila selama beberapa minggu terakhir. Saya bisa melihat Model secara otomatis resolved dan injected, dan saya pikir saya mengerti mekanisme yang terlibat, tetapi tidak peduli apa yang saya coba, saya tidak bisa membuatnya berfungsi di luar contoh-contoh tertentu dalam dokumentasi Filament."}),"\n",(0,t.jsx)(n.h2,{id:"kesalahan-kedua-berpikir-bahwa-service-container-dapat-resolve-model-instances",children:"Kesalahan kedua: Berpikir bahwa Service Container dapat resolve Model instances"}),"\n",(0,t.jsx)(n.p,{children:"Pada saat itu, ini tampaknya sepenuhnya jelas (dengan lompatan logis yang salah di atas), tetapi kebenaran sederhana adalah ini: Service Container tidak dapat secara otomatis menyelesaikan contoh spesifik dari Model Anda, dalam keadaan, skenario, kondisi, atau situasi apa pun, sama sekali tidak. Untuk Service Container mengambil contoh spesifik dari Model, ANDA HARUS memberikan nilai identifikasi kepadanya (seperti ID Model)."}),"\n",(0,t.jsx)(n.p,{children:"Saya benar-benar telah membuang waktu berminggu-minggu untuk hal ini. Hal-hal yang saya coba tidak berhasil:"}),"\n",(0,t.jsx)(n.h3,{id:"using-the-app-facade",children:"Using the App Facade"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$environment = app(Environment::class); //This does not work, returns a blank Environment\n"})}),"\n",(0,t.jsx)(n.p,{children:'Ini tidak akan pernah berhasil. Itu akan selalu mengembalikan contoh "kosong/blank" dari Model Anda. Bahkan jika Anda mencobanya dalam konteks yang sama persis dengan tempat kerja injeksi Filamen, itu tetap tidak akan berhasil.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"Action::make(\"undo\")\r\n->button()\r\n->requiresConfirmation()\r\n->label(\"Undo\")\r\n->icon('heroicon-m-x-mark')\r\n->color('danger')\r\n->action(function (Environment $environment) {\r\n\\Debugbar::alert($environment); //This works, shows the current Environment\r\n\\Debugbar::alert(app(Environment::class)); //This does not work, shows a blank Environment\r\nreturn $environment->executeUndo();\r\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"using-constructor-injection",children:"Using Constructor Injection"}),"\n",(0,t.jsxs)(n.p,{children:["Inilah yang paling membuat saya patah. Ide bahwa Anda dapat inject dependencies melalui ",(0,t.jsx)(n.code,{children:"__constructor()"}),' dalam kelas-kelas Anda tampaknya menjadi... hal paling inti dari Laravel. Ada banyak contoh yang persis seperti ini ketika Anda mencari "Laravel Dependency Injection" di Google, tetapi ternyata tidak ada yang (ok, mungkin hanya beberapa) dari mereka yang mau menyebutkan bahwa ini tidak berkerja dengan Model instances.']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class Example\r\n{\r\n  public function __construct(\r\n    public Environment $environment,\r\n  ) {}\r\n\r\n  public function getEnvironment()\r\n  {\r\n    \\Debugbar::alert($this->environment); //This does not work, shows a blank Environment\r\n    return $this->environment;\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"any-form-of-service-container-bindings",children:"Any form of Service Container Bindings"}),"\n",(0,t.jsx)(n.p,{children:'Anda pikir Anda dapat mengatasinya dengan beberapa jenis Service class binding, injecting Model sebagai bagian dari definisinya? Tidak. Anda mungkin berpikir "tapi kita menggunakan fungsi anonim, dan menyertakan Model sebagai parameter? Ini berhasil di tempat lain dalam Filament!". Tidak bisa. Tidak berhasil.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"public function register(): void\r\n{\r\n  $this->app->bind(EnvironmentService::class, function (Environment $environment) {\r\n    return new EnvironmentService($environment);\r\n  });\r\n}\r\n$service = app(EnvironmentService::class); //Will return your Service class, but the $environment attribute will be a blank Environment\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Jangan berpikir Anda bisa menjadi rumit dengan ",(0,t.jsx)(n.a,{href:"https://laravel.com/docs/10.x/container#contextual-binding",children:"Contextual Bindings"})," atau ",(0,t.jsx)(n.a,{href:"https://laravel.com/docs/10.x/providers#deferred-providers",children:"Deferred Service Provider"}),". Terutama dengan yang terakhir, menunda injeksi sampai Anda benar-benar meminta kelas terikat, sepertinya itu bisa membantu, bukan? Tidak."]}),"\n",(0,t.jsx)(n.h3,{id:"creating-and-evaluating-my-own-closures",children:"Creating and evaluating my own Closures"}),"\n",(0,t.jsx)(n.p,{children:"Lalu saya berpikir, Filament tampaknya dapat memasukkan Model ke dalam Closures - jadi mari kita coba membuat closure di lokasi yang berbeda, dan melihat apakah closure tersebut dapat teratasi/resolve? Itu tidak. Bahkan ketika dipanggil bersebelahan, seperti pada contoh di bawah, itu tidak akan berhasil."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:'class EnvironmentService\r\n{\r\n  use Filament\\Support\\Concerns\\EvaluatesClosures;\r\n\r\n  public function getEnvironment()\r\n  {\r\n    return $this->evaluate(fn (Environment $environment) => $environment);\r\n  }\r\n}\r\n\r\nAction::make("action")\r\n  ->action(function (Environment $environment) {\r\n  \\Debugbar::alert($environment); //This works, shows the current Environment\r\n  $service = app(EnvironmentService::class);\r\n  \\Debugbar::alert($service->getEnvironment()); //Blank Environment\r\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"Saya menghabiskan waktu berjam-jam bermain-main dengan Closures, mencoba memahami mengapa mereka berhasil dalam beberapa skenario, tetapi tidak pada skenario lainnya. Saya terus memikirkan hal ini, karena pada intinya, saya entah bagaimana telah meyakinkan diri saya sendiri akan kesalahan berikutnya."}),"\n",(0,t.jsxs)(n.h2,{id:"kesalahan-ketiga-berpikir-bahwa-route-model-binding-digunakan-untuk-menyelesaikan-model",children:["Kesalahan ketiga: Berpikir bahwa ",(0,t.jsx)(n.code,{children:"Route Model Binding"})," digunakan untuk menyelesaikan Model"]}),"\n",(0,t.jsxs)(n.p,{children:["Untuk memahami bagaimana ",(0,t.jsx)(n.code,{children:"Service Container"}),' dapat resolve Model instances (yang sebenarnya tidak), saya percaya (tanpa bukti dukungan yang nyata, selain "tidak ada yang memberi tahu saya sebaliknya"), bahwa mekanisme yang ',(0,t.jsx)(n.code,{children:"Service Container"})," (dan oleh karena itu Filament) harus menggunakan untuk menyelesaikan Model adalah ",(0,t.jsx)(n.a,{href:"https://laravel.com/docs/10.x/routing#route-model-binding",children:"Route Model Binding"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Pada permukaannya, ini masuk akal \u2014 baik ",(0,t.jsx)(n.code,{children:"Service Container"}),", maupun konsep ",(0,t.jsx)(n.code,{children:"Route Model Binding"})," adalah bagian inti dari Laravel, dan haruslah menemukan Model saat ini ",(0,t.jsx)(n.em,{children:'"dengan cara apa pun"'}),". ",(0,t.jsx)(n.code,{children:"Route Model Binding/RMB"})," tampaknya menjadi tebakan yang masuk akal seperti yang lainnya."]}),"\n",(0,t.jsx)(n.p,{children:"Ternyata, saya hampir benar."}),"\n",(0,t.jsxs)(n.p,{children:["Tanpa terlalu teknis, ",(0,t.jsx)(n.code,{children:"Route Model Binding"})," menggunakan ",(0,t.jsx)(n.code,{children:"Service Container"})," untuk memberikan Model yang telah diselesaikan, tetapi ",(0,t.jsx)(n.code,{children:"Service Container"})," tidak dapat menggunakan ",(0,t.jsx)(n.code,{children:"Route Model Binding"})," untuk resolve Model. Ini adalah hubungan satu arah \u2014 dari RMB ke SC. Anda dapat membaca lebih lanjut tentang hal itu di sini."]}),"\n",(0,t.jsxs)(n.p,{children:["Artinya adalah bahwa semua upaya saya untuk menarik Model yang diinstansiasi keluar dari ",(0,t.jsx)(n.code,{children:"Service Container"})," sudah ditakdirkan gagal dari awal. Satu-satunya cara SC akan pernah menerima Model yang diinstansiasi adalah jika RMB mengirimkannya, dan karena Filament tidak menggunakan Controller... ini tidak akan pernah terjadi."]}),"\n",(0,t.jsxs)(n.p,{children:["Hal lain yang saya salah tentang? Filament menggunakan ",(0,t.jsx)(n.code,{children:"Route Model Binding"}),", hanya saja bukan ",(0,t.jsx)(n.code,{children:"Route Model Binding"})," Laravel..."]}),"\n",(0,t.jsx)(n.h2,{id:"jadi-bagaimana-sebenarnya-cara-kerjanya-ini-adalah-penjelasan-tldr",children:"Jadi, bagaimana sebenarnya cara kerjanya? (Ini adalah penjelasan TL;DR)"}),"\n",(0,t.jsxs)(n.p,{children:["Kunci untuk memahami ",(0,t.jsx)(n.code,{children:"Dependency Injection"})," di Filament adalah sebagai berikut:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Dependency Injection di Laravel dilakukan melalui dua komponen terpisah (untuk memahaminya): ",(0,t.jsx)(n.code,{children:"Service Container"}),", dan ",(0,t.jsx)(n.code,{children:"Route Model Binding"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Di Filament, ",(0,t.jsx)(n.code,{children:"Service Container"})," Laravel sepenuhnya tidak disentuh, dan beroperasi persis seperti yang dilakukan dalam Laravel reguler."]}),"\n",(0,t.jsxs)(n.li,{children:["Di Filament, ",(0,t.jsx)(n.code,{children:"Route Model Binding"})," Laravel sama sekali tidak digunakan."]}),"\n",(0,t.jsxs)(n.li,{children:["Filament telah membuat mekanisme ",(0,t.jsx)(n.code,{children:"Dependency Injection"})," yang sepenuhnya terpisah dan mandiri, yang digunakan untuk menyuntikkan Model (dan objek lain) ke dalam ",(0,t.jsx)(n.code,{children:"Closures"}),". ",(0,t.jsxs)(n.em,{children:["Injection ",(0,t.jsx)(n.code,{children:"Closure"})," ini unik untuk Filament"]}),". Sebagai pemula dalam Laravel dan Filament, saya sama sekali tidak memiliki pemahaman tentang ini \u2014 saya hanya menganggapnya sebagai bagian inti dari Laravel!"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DI extension"}),"Filament menggunakan ",(0,t.jsx)(n.a,{href:"https://livewire.laravel.com/docs/components#using-route-model-binding",children:"Livewire\u2019s Route Model Binding"}),", bukan ",(0,t.jsx)(n.code,{children:"Route Model Binding"})," Laravel."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DI extension"}),"Filament akan melakukannya, jika tidak mampu menyelesaikan objek yang diminta secara mandiri, kembali ke ",(0,t.jsx)(n.code,{children:"Service Container"})," dan mengembalikan apa pun yang dapat ditemukannya. Ini adalah satu-satunya hubungan antara kedua sistem tersebut."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:['"secara ketat bicara, ini bukanlah sesuatu yang unik untuk Filament, Anda ',(0,t.jsx)(n.a,{href:"https://darkghosthunter.medium.com/laravel-dependency-injection-on-methods-and-closures-ac17c7d5e8d1",children:"dapat melakukannya di Laravel"}),", hanya saja tidak umum dalam gaya pengembangan."]}),"\n",(0,t.jsx)(n.h2,{id:"tunggu-bagaimana-service-container-bekerja",children:"Tunggu, bagaimana Service Container bekerja?"}),"\n",(0,t.jsxs)(n.p,{children:["Karena ",(0,t.jsx)(n.code,{children:"Service Container"})," Laravel tidak memiliki keterkaitan apa pun (selain menjadi \u201Cpilihan terakhir\u201D ketika DI Filament tidak cocok), Anda dapat menggunakannya persis seperti yang Anda lakukan dalam Laravel biasa, dan berfungsi dengan tepat sama. Tetapi ingatlah satu peringatan besar: Anda hanya dapat secara otomatis inject objects yang dapat Anda resolve dalam kode yang telah ditetapkan."]}),"\n",(0,t.jsx)(n.p,{children:"Ini masih sangat berguna, dan jika diperlukan, ada banyak cara untuk menginisialisasi Model tertentu. Sebagai contoh, jika Anda memiliki kelas Service yang perlu mengetahui tentang Model terkaitnya, Anda bisa menyuntikkannya melalui facade App, atau secara eksplisit mengambil Model dalam kode:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class EnvironmentService\r\n{\r\n  public function __construct(\r\n    public Environment $environment,\r\n  ) {}\r\n\r\n  public static function make($id)\r\n  {\r\n    return new Environment(Environment::findOrFail($id));\r\n  }\r\n}\r\n\r\n$environment = EnvironmentService::make(34); //Will return the Environment model with ID 34.\r\n$environment = app(EnvironmentService::class, ['environment' => 34]); //Same thing as above.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Saya yakin praktik terbaik yang diterima secara umum adalah menggunakan ",(0,t.jsx)(n.code,{children:"app() facade"})," sebagai ",(0,t.jsx)(n.code,{children:"factory"})," untuk kelas Anda, bahkan jika Anda harus memberikan ID-nya. Itu masih akan mengelola semua dependensi yang dapat diselesaikan, itu akan menyelesaikan Antarmuka ke dalam kelas-kelas konkret, Anda dapat menggunakannya untuk membangun objek kompleks dengan rantai dependensi - Anda tidak bisa memasukkan sebuah instance Model tanpa memasukkan ID tertentu."]}),"\n",(0,t.jsx)(n.h2,{id:"tell-me-more-about-filaments-custom-dependency-injection",children:"Tell me more about Filament\u2019s custom Dependency Injection"}),"\n",(0,t.jsx)(n.p,{children:"Here is the short version."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Filament\u2019s Pages are full-page Livewire components, and as such, are able to resolve the current Model."}),"\n",(0,t.jsx)(n.li,{children:"When you define a Component on that page, that Model is passed on to it."}),"\n",(0,t.jsx)(n.li,{children:"Filament\u2019s DI operates on these Components (that is, classes that extend from \\Filament\\Support\\Components\\Component)."}),"\n",(0,t.jsx)(n.li,{children:"When you are calling methods on these Components, besides setting primitives, you can almost universally also pass in Closures"}),"\n",(0,t.jsx)(n.li,{children:"These Closures are evaluated by the evaluate() method in the EvaluatesClosures trait."}),"\n",(0,t.jsx)(n.li,{children:"The evaluate() method then (short version) looks back up the chain to find the list of parameters it is able to resolve, and how to resolve them."}),"\n",(0,t.jsx)(n.li,{children:"For Models, it simply returns the Model that was set back when the Component was first created."}),"\n",(0,t.jsx)(n.li,{children:"The rest of the parameters are resolved on a case by case basis."}),"\n",(0,t.jsx)(n.li,{children:"If it can\u2019t resolve the requested injection, it will go and ask the Service Container if it has anything. This is the only interface between the two DI systems."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This explains the \u201Ccontext\u201D of Filament\u2019s DI. It works on classes that extend from \\Filament\\Support\\Components\\Component. In order to find the exact list of parameters you can inject, it looks for the resolveDefaultClosureDependencyForEvaluationByName() and resolveDefaultClosureDependencyForEvaluationByType() methods, where you will find the code that defines precisely what can be injected, and where it will be injected from."}),"\n",(0,t.jsx)(n.h2,{id:"whats-the-long-version",children:"What\u2019s the Long Version?"}),"\n",(0,t.jsx)(n.p,{children:"Here it is, the detailed explanation of exactly how Filament\u2019s DI works. It\u2019s a bit long, but I\u2019ll try and step through it as carefully as I can. For the sake of this explanation, I will be using a View Page for the Environment resource we\u2019ve been using as an example so far, but the same mechanics apply to all the Pages."}),"\n",(0,t.jsx)(n.h2,{id:"it-starts-with-livewire",children:"It starts with Livewire"}),"\n",(0,t.jsxs)(n.p,{children:["If you look at\xa0",(0,t.jsx)(n.a,{href:"https://livewire.laravel.com/docs/components#full-page-components",children:"https://livewire.laravel.com/docs/components#full-page-components"}),", you will see there are three main conditions we need to meet for Route Model Binding:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"You create a class that extends Livewire\\Component"}),"\n",(0,t.jsx)(n.li,{children:"You create a Route defined that points to your new class"}),"\n",(0,t.jsx)(n.li,{children:"The new class has a property (and/or mount() method) whose Model and property name match the values from the Route"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Then, if you visit the URL from your Route, with a valid ID in place, Livewire will boot the class, with the property of your Model already correctly instantiated."}),"\n",(0,t.jsx)(n.h2,{id:"how-is-this-done-in-filament",children:"How is this done in Filament?"}),"\n",(0,t.jsx)(n.p,{children:"The above conditions are met through the following Filament components:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ONE"}),"\xa0\u2014 Creating a Page (for our example, a View record \u2014\xa0",(0,t.jsx)(n.a,{href:"https://filamentphp.com/docs/3.x/panels/resources/viewing-records",children:"https://filamentphp.com/docs/3.x/panels/resources/viewing-records"}),"). The created class, ViewEnvironment, extends ViewRecord, which extends Page, so on and so on, until eventually you get down to Livewire\\Component"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class ViewEnvironment extends ViewRecord\r\n{\r\n protected static string $resource = EnvironmentResource::class;\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"TWO"}),"\xa0\u2014 To create the Route, you add your route to the getPages() method in your Resource, as per\xa0",(0,t.jsx)(n.a,{href:"https://filamentphp.com/docs/3.x/panels/resources/viewing-records#adding-a-view-page-to-an-existing-resource",children:"https://filamentphp.com/docs/3.x/panels/resources/viewing-records#adding-a-view-page-to-an-existing-resource"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"public static function getPages(): array\r\n{\r\n return [\r\n'index' => Pages\\ListEnvironments::route('/'),\r\n'create' => Pages\\CreateEnvironment::route('/create'),\r\n'view' => Pages\\ViewEnvironment::route('/{record}'),\r\n'edit' => Pages\\EditEnvironment::route('/{record}/edit'),\r\n];\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"THREE"}),"\xa0\u2014 The class ViewRecord, which our class extends, defines the mount() method, and uses the Concerns\\InteractsWithRecord trait, which is where the $record property is defined."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class ViewRecord extends Page\r\n{\r\n use Concerns\\HasRelationManagers;\r\n use Concerns\\InteractsWithRecord;\r\n use InteractsWithFormActions;\r\n\r\n// - -\r\n\r\npublic function mount(int | string $record): void  {\r\n    $this->record = $this->resolveRecord($record);\r\n $this->authorizeAccess();\r\n if (! $this->hasInfolist()) {\r\n $this->fillForm();\r\n }\r\n }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"And that\u2019s it \u2014 all you need to do, as a developer, is create a Page as per the instructions, and the magic begins!"}),"\n",(0,t.jsx)(n.h2,{id:"getting-the-record-into-the-right-places",children:"Getting the Record into the right places"}),"\n",(0,t.jsx)(n.p,{children:"From the Page, the Record is passed through into the Component during creation. In our example, we\u2019re looking at an Infolist on our View Page. This is all done automatically, the Components are initialised during the mount() method of the Page, and ."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class ViewRecord extends Page\r\n{\r\n // - -\r\n\r\nprotected function makeInfolist(): Infolist {\r\n return parent::makeInfolist()\r\n ->record($this->getRecord())\r\n      ->columns($this->hasInlineLabels() ? 1 : 2)\r\n ->inlineLabel($this->hasInlineLabels());\r\n }\n"})}),"\n",(0,t.jsx)(n.h2,{id:"now-to-fetch-this-record",children:"Now to fetch this Record"}),"\n",(0,t.jsx)(n.p,{children:"From here, we go right down to the other end of the chain \u2014 where the Closure is actually defined, and asks for the Environment to be injected."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"public static function infolist(Infolist $infolist): Infolist\r\n{\r\n return $infolist\r\n ->schema([\r\n Section::make('Overview')\r\n ->columns(4)\r\n ->heading(fn(Environment $environment) => $environment->name)\r\n ->schema([\r\n// - -\r\n])\r\n ]);\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"evaluating-the-closure",children:"Evaluating the Closure"}),"\n",(0,t.jsx)(n.p,{children:"When, at some later point, Filament needs to display the heading that we\u2019ve set, it calls the evaluate() method to process it."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"trait HasHeading\r\n{\r\n protected string | Htmlable | Closure | null $heading = null;\r\n\r\npublic function heading(string | Htmlable | Closure | null $heading = null): static {\r\n $this->heading = $heading;\r\n return $this;\r\n }\r\n\r\npublic function getHeading(): string | Htmlable | null {\r\n return $this->evaluate($this->heading);\r\n }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The evaluate() method is where a lot of the magic happens, but it\u2019s relatively simple in concept \u2014 it is able to go and resolve a dependency based either on Name, or on Type. This is why injecting either Environment $environment or Environment $record both work."}),"\n",(0,t.jsx)(n.p,{children:"Eventually, it gets to the point where it calls the two following methods: resolveDefaultClosureDependencyForEvaluationByName() and resolveDefaultClosureDependencyForEvaluationByType(). Their implementation in the Trait is only a placeholder \u2014 they are meant to be implemented further up the chain, in the case of our Infolist, the file is Filament\\Infolists\\ComponentContainer"}),"\n",(0,t.jsx)(n.h2,{id:"implementing-the-evaluations",children:"Implementing the Evaluations"}),"\n",(0,t.jsxs)(n.p,{children:["For this example,\xa0",(0,t.jsx)(n.strong,{children:"I\u2019m hopping over to the implementation in Filament\\Forms\\Components\\Component"}),", because it\u2019s more interesting than the Infolist one."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"protected function resolveDefaultClosureDependencyForEvaluationByName(string $parameterName): array\r\n{\r\n  return match ($parameterName) {\r\n 'context', 'operation' => [$this->getContainer()->getOperation()],\r\n 'get' => [$this->getGetCallback()],\r\n 'livewire' => [$this->getLivewire()],\r\n 'model' => [$this->getModel()],\r\n 'record' => [$this->getRecord()],\r\n 'set' => [$this->getSetCallback()],\r\n 'state' => [$this->getState()],\r\n default => parent::resolveDefaultClosureDependencyForEvaluationByName($parameterName),\r\n };\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, this is the complete list of parameters you can inject on a form component! Much of this is documented\xa0",(0,t.jsx)(n.a,{href:"https://filamentphp.com/docs/3.x/forms/advanced#form-component-utility-injection",children:"here"}),", but by digging into the code itself, you can see a definitive list of what it is you can and cannot inject. For any class that lets you pass in Closures and resolve their dependencies, there will be an implementation of this (and the ByType) method. Go check them out!"]}),"\n",(0,t.jsx)(n.p,{children:"Also note \u2014 if the parameter you\u2019re trying to inject isn\u2019t in the available list, Filament\u2019s DI will go and ask the Service Container if it has anything. This is the only interaction between the two systems."}),"\n",(0,t.jsx)(n.h2,{id:"the-final-piece-of-the-puzzle",children:"The final piece of the puzzle"}),"\n",(0,t.jsx)(n.p,{children:"As you may have already seen in the code above\u2026 This is where the connection between Filament\u2019s DI and Livewire\u2019s Route Model Binding happens!"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"'model' => [$this->getModel()],\r\n'record' => [$this->getRecord()],\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Filament\u2019s DI isn\u2019t so much\xa0",(0,t.jsx)(n.em,{children:"resolving"}),"\xa0the Model instance, it\u2019s just passing on the instance that was set when the Component was first created. And that\u2019s all there is to it! You know have a pretty thorough understanding of exactly where and when you are able to use Filament\u2019s DI, and more importantly, WHY!"]}),"\n",(0,t.jsx)(n.h2,{id:"why-are-there-two-different-resolvedefault-methods",children:"Why are there two different resolveDefault methods?"}),"\n",(0,t.jsxs)(n.p,{children:["The reason there is both a resolveDefaultClosureDependencyForEvaluationBy",(0,t.jsx)(n.strong,{children:"Name"}),"() and resolveDefaultClosureDependencyForEvaluationBy",(0,t.jsx)(n.strong,{children:"Type"}),"() is the entire reason for Filament\u2019s custom DI to even exist. It allows the injection of records either by name or by type"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"->action(function (Environment $record) { //here the resolution is by name\r\n return $environment->executeUndo();\r\n});\r\n->action(function (Environment $environment) { //here the resolution is by type\r\n return $environment->executeUndo();\r\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Both of the above examples work perfectly, but being able to resolve by Type is unique to Filament."}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["I wrote this article because I felt that if I was having these problems coming to grips with Dependency Injection in Filament, then other people might be as well. I don\u2019t pretend to be an amazing programmer, but some of the things I\u2019ve discovered throughout this process haven\u2019t felt particularly obvious to me. It wasn\u2019t until I received the specific guidance on how some of the internals work from one of Filament\u2019s core developers that things started clicking into place (",(0,t.jsx)(n.a,{href:"https://github.com/pxlrbt",children:"thanks Dennis"}),"!) Hopefully this helps someone else getting into Filament for the first time, or at the very least, saves them from making the same stupid mistakes I did!"]}),"\n",(0,t.jsx)(n.p,{children:"And as it also turns out, Dan Harris, the creator of Filament, actually has a video that describes some of what I\u2019ve covered above. I didn\u2019t know about the existence of this until after I\u2019d worked all the above out for myself, I\u2019m sure it would have saved me a mountain of frustration."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://laracasts.com/series/build-advanced-components-for-filament/episodes/2",children:"https://laracasts.com/series/build-advanced-components-for-filament/episodes/2"})}),"\n",(0,t.jsxs)(n.p,{children:["Dan himself also mentioned:\xa0",(0,t.jsx)(n.em,{children:"\u201CFilament\u2019s DI ($this->evaluate()) is actually based on Laravel\u2019s own DI feature (app()->call()) which does exactly the same thing to closure functions. the only reason Filament uses $this->evaluate() instead, is because we have a feature where we can inject parameters based on their type as well as their name. so Post $record does the same as Post $post as we tell the evaluation that Post types can be injected as well as $record. laravel cant do that with app()->call(). but what we are doing is basically identical to Laravel, its not really that magic.\u201D"})]}),"\n",(0,t.jsx)(n.p,{children:"I would counter that it certainly feels like magic to a developer seeing it for the first time, but once you take a peek inside and see behind the curtain, it might not be magic, but it certainly is elegant!"})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},50065:function(e,n,a){a.d(n,{Z:function(){return l},a:function(){return s}});var i=a(67294);let t={},r=i.createContext(t);function s(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);